= Include Installation

The include installation system provides a clean way to integrate Bazel-generated configuration files with existing system configurations using include directives.

== Overview

Instead of injecting configuration content directly into target files, the include installation system:

1. **Generates** configuration files using Bazel
2. **Injects** small include directives that point to the generated files
3. **Manages** these directives with guard comments for easy updates

This approach provides better separation of concerns and leverages native include mechanisms supported by many configuration formats.

== Flexible Include Directives

The system uses a template-based approach for maximum flexibility. You specify the exact include directive you want using `{path}` as a placeholder for the configuration file path.

[cols="1,2,3"]
|===
|Config Type |Include Directive Template |Result

|Git
|`"[include]\\n\\tpath = {path}"`
|`[include]` section with path

|Vim/ZSH/Bash
|`"source {path}"`
|`source` command

|Tmux
|`"source-file {path}"`
|`source-file` command

|Custom
|`"load {path}"`
|Any custom format you need
|===

== Basic Usage

[source,starlark]
----
load("//rules:include_install.bzl", "include_install")

include_install(
    name = "install_gitconfig",
    target_file = "~/.gitconfig",
    config = ":gitconfig",  # Bazel-generated config file
    identifier = "dotfiles",
    include_directive = "[include]\\n\\tpath = {path}",
    header_comment = "#",
)
----

Running the installations:

[source,bash]
----
# Install Git configuration
bazel run //src/git:install_gitconfig

# Install Vim configuration
bazel run //src/vim:install_vimrc

# Install Tmux configuration
bazel run //src/tmux:install_tmux_conf

# Install ZSH configuration
bazel run //src/zsh:install_zshrc
----

== How It Works

=== Generated Include Directives

The system injects guarded include directives into your target files using the appropriate format:

**Git Config (.gitconfig):**
[source,gitconfig]
----
[user]
    # your existing config

# guard:begin:dotfiles
[include]
    path = /Users/user/dotfiles/bazel-bin/src/git/gitconfig.gitconfig
# guard:end:dotfiles
----

**Vim Config (.vimrc):**
[source,vim]
----
" your existing config

" guard:begin:dotfiles
source /Users/user/dotfiles/bazel-bin/src/vim/vimrc.vim
" guard:end:dotfiles
----

**Tmux Config (.tmux.conf):**
[source,tmux]
----
# your existing config

# guard:begin:dotfiles
source-file /Users/user/dotfiles/bazel-bin/src/tmux/tmux.conf
# guard:end:dotfiles
----

**ZSH Config (.zshrc):**
[source,zsh]
----
# your existing config

# guard:begin:dotfiles
source /Users/user/dotfiles/bazel-bin/src/zsh/generated_zshrc.zsh
# guard:end:dotfiles
----

=== Guard Management

- **Unique identifiers**: Each include directive has a unique identifier
- **Atomic updates**: Uses temporary files for safe operations
- **Idempotent**: Running multiple times updates the existing directive
- **Deterministic**: Same identifier always manages the same section

== Configuration

=== Required Parameters

[cols="1,1,3"]
|===
|Parameter |Type |Description

|`name`
|string
|Name of the installation rule

|`target_file`
|string
|Path to target file (supports `~` expansion)

|`config`
|label
|Bazel target that generates the configuration file

|`identifier`
|string
|Unique identifier for the include directive
|===

=== Optional Parameters

[cols="1,1,1,3"]
|===
|Parameter |Type |Default |Description

|`include_directive`
|string
|*required*
|Template for include directive using `{path}` placeholder

|`header_comment`
|string
|`"#"`
|Comment character for guard comments

|`backup`
|bool
|`false`
|Create timestamped backup files

|`create_if_missing`
|bool
|`true`
|Create target file if it doesn't exist
|===

== Examples

=== Git Configuration

[source,starlark]
----
# Generate profile-aware gitconfig
git_config(
    name = "gitconfig",
    srcs = select({
        "//config:personal": [":personal_configs"],
        "//config:work": [":work_configs"],
        "//conditions:default": [":base_configs"],
    }),
)

# Install using include directive
include_install(
    name = "install_gitconfig",
    target_file = "~/.gitconfig",
    config = ":gitconfig",
    identifier = "dotfiles",
    include_directive = "[include]\\n\\tpath = {path}",
)
----

=== Vim Configuration

[source,starlark]
----
# Install vim config using source directive
include_install(
    name = "install_vimrc",
    target_file = "~/.vimrc",
    config = ":vimrc",
    identifier = "dotfiles",
    include_directive = "source {path}",
    header_comment = "\"",
)
----

=== Tmux Configuration

[source,starlark]
----
# Install tmux config using source-file directive
include_install(
    name = "install_tmux_conf",
    target_file = "~/.tmux.conf",
    config = ":tmux_conf",
    identifier = "dotfiles",
    include_directive = "source-file {path}",
)
----

=== ZSH Configuration

[source,starlark]
----
# Install zsh config using source directive
include_install(
    name = "install_zshrc",
    target_file = "~/.zshrc",
    config = ":generated_zshrc",
    identifier = "dotfiles",
    include_directive = "source {path}",
)
----

=== Multiple Include Directives

You can have multiple include directives in the same file with different identifiers:

[source,starlark]
----
include_install(
    name = "install_git_aliases",
    target_file = "~/.gitconfig",
    config = ":git_aliases",
    identifier = "aliases",
)

include_install(
    name = "install_git_core",
    target_file = "~/.gitconfig",
    config = ":git_core",
    identifier = "core_config",
)
----

=== SSH Configuration

[source,starlark]
----
include_install(
    name = "install_ssh_config",
    target_file = "~/.ssh/config",
    config = ":ssh_config",
    identifier = "work_hosts",
    include_directive = "Include {path}",
    header_comment = "#",
)
----

=== Custom Include Formats

The flexible template system allows you to use any include format:

[source,starlark]
----
# Nginx include
include_install(
    name = "install_nginx_config",
    target_file = "/etc/nginx/nginx.conf",
    config = ":nginx_config",
    identifier = "custom_rules",
    include_directive = "include {path};",
)

# Apache include
include_install(
    name = "install_apache_config",
    target_file = "/etc/apache2/apache2.conf",
    config = ":apache_config",
    identifier = "custom_modules",
    include_directive = "Include {path}",
)

# Multi-line include with custom formatting
include_install(
    name = "install_complex_config",
    target_file = "~/.config/app/config.conf",
    config = ":app_config",
    identifier = "app_settings",
    include_directive = "# Generated config\\nload_config(\"{path}\")",
)
----

== Benefits

=== Clean Separation
- Generated content stays in Bazel-managed files
- Target files only contain small include directives
- Easy to see what's managed vs. manual configuration

=== Native Support
- Leverages built-in include mechanisms (Git, SSH, etc.)
- No custom parsing or content injection
- Works with existing tooling and validation

=== Atomic Updates
- Include path updates atomically when config changes
- No risk of partial updates or corruption
- Rollback by simply rebuilding with previous version

=== Profile Integration
- Works seamlessly with profile-aware configuration generation
- Include path automatically updates when profile changes
- Single command to rebuild and reinstall: `bazel run //target --//config:profile=work`

== Comparison with Other Approaches

[cols="1,2,2,2"]
|===
|Approach |Pros |Cons |Best For

|**Include Install**
|Clean separation, native support, atomic updates
|Requires include support in target format
|Git, SSH, shell configs

|Sectioned Install
|Works with any format, direct content injection
|More complex, content mixed with target file
|Legacy formats without include support

|Guarded Install
|Simple, works everywhere
|Replaces entire file, no incremental updates
|Small, standalone config files
|===

== Troubleshooting

=== Include Path Issues

If the include directive points to a non-existent file:

1. **Rebuild** the configuration: `bazel build //your:config`
2. **Check** the path exists: `ls -la bazel-out/.../your_config.ext`
3. **Reinstall**: `bazel run //your:install_target`

=== Permission Errors

Ensure you have write permissions to the target file and directory:

[source,bash]
----
ls -la ~/.gitconfig
ls -ld ~/.ssh
----

=== Multiple Identifiers

Each identifier manages an independent section. To avoid conflicts:

- Use descriptive, unique identifiers
- Document which identifiers are used for each file
- Consider using prefixes: `dotfiles_git`, `dotfiles_ssh`
