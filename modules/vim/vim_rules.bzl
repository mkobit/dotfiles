"""Rules for generating Vim configuration files."""

# Define the VimConfigInfo provider to make configuration data strongly typed
VimConfigInfo = provider(
    doc = "Information about Vim configuration",
    fields = {
        "settings": "Dictionary of vim settings",
        "plugins": "List of vim plugins to include",
        "includes": "List of other vim configs to include",
        "platform_specific": "Platform-specific settings",
        "raw_statements": "Raw Vim script statements to include",
        "mappings": "Keyboard mappings to include",
    },
)

def _normalize_bool_setting(value):
    """Normalize boolean settings to Vim syntax."""
    if value == True:
        return "set"
    elif value == False:
        return "set no"
    return value

def _vim_config_impl(ctx):
    """Implementation of vim_config rule."""
    # Process includes first to set up inheritance
    inherited_settings = {}
    inherited_platform_settings = {}
    inherited_raw_statements = []
    inherited_mappings = {}

    # Process includes (nested configs) and inherit their values
    for include in ctx.attr.includes:
        include_info = include[VimConfigInfo]
        # Merge settings
        for key, value in include_info.settings.items():
            if key not in inherited_settings:
                inherited_settings[key] = value

        # Merge platform-specific settings
        for platform, settings_list in include_info.platform_specific.items():
            if platform not in inherited_platform_settings:
                inherited_platform_settings[platform] = []
            inherited_platform_settings[platform].extend(settings_list)

        # Merge raw statements
        if hasattr(include_info, "raw_statements") and include_info.raw_statements:
            inherited_raw_statements.extend(include_info.raw_statements)

        # Merge mappings
        if hasattr(include_info, "mappings") and include_info.mappings:
            for key, mapping in include_info.mappings.items():
                if key not in inherited_mappings:
                    inherited_mappings[key] = mapping

    # Create a dictionary to hold our configuration, starting with inherited values
    settings = dict(inherited_settings)

    # Override with settings from the rule attributes
    for key, value in ctx.attr.settings.items():
        settings[key] = value

    # Handle platform-specific settings
    platform_settings = dict(inherited_platform_settings)
    for platform, platform_list in ctx.attr.platform_settings.items():
        if platform not in platform_settings:
            platform_settings[platform] = []
        platform_settings[platform].extend(platform_list)

    # Add raw statements
    raw_statements = list(inherited_raw_statements)
    for stmt in ctx.attr.raw_statements:
        raw_statements.append(stmt)

    # Add mappings
    mappings = dict(inherited_mappings)
    for key, mapping in ctx.attr.mappings.items():
        mappings[key] = mapping

    # Create the provider
    config = VimConfigInfo(
        settings = settings,
        includes = ctx.attr.includes,
        platform_specific = platform_settings,
        raw_statements = raw_statements,
        mappings = mappings,
    )

    return [config]

vim_config = rule(
    implementation = _vim_config_impl,
    attrs = {
        "settings": attr.string_dict(
            doc = "Dictionary of vim settings",
            default = {},
        ),
        "includes": attr.label_list(
            doc = "Other vim_config targets to include",
            default = [],
            providers = [VimConfigInfo],
        ),
        "platform_settings": attr.string_list_dict(
            doc = "Platform-specific settings",
            default = {},
        ),
        "raw_statements": attr.string_list(
            doc = "Raw Vim script statements to include",
            default = [],
        ),
        "mappings": attr.string_dict(
            doc = "Keyboard mappings to include (key to command)",
            default = {},
        ),
    },
)

def _get_platform_string(ctx):
    """Determine the current platform."""
    if ctx.target_platform_has_constraint(ctx.attr._windows_constraint[platform_common.ConstraintValueInfo]):
        return "windows"
    elif ctx.target_platform_has_constraint(ctx.attr._macos_constraint[platform_common.ConstraintValueInfo]):
        return "macos"
    else:
        return "linux"  # Default to Linux

def _vim_config_generator_impl(ctx):
    """Implementation for vim_config_generator rule that generates a .vimrc file."""
    # Get the VimConfigInfo provider from the config target
    config_info = ctx.attr.config[VimConfigInfo]

    # Determine the platform
    platform = _get_platform_string(ctx)

    # Prepare the output file
    output = ctx.actions.declare_file(ctx.attr.name + ".vimrc")
    content = []

    # Generate file header
    content.append('""" Generated .vimrc file - DO NOT EDIT """')
    content.append('""" Generated by Bazel from {}"""'.format(ctx.label))
    content.append('""" Platform: {} """'.format(platform))
    content.append("")

    # Add basic configurations
    content.append('" Basic Settings')
    for key, value in config_info.settings.items():
        # Handle string-based boolean values
        if value == "true":
            content.append('set {}'.format(key))
        elif value == "false":
            content.append('set no{}'.format(key))
        else:
            # Handle other values
            content.append('set {}={}'.format(key, value))

    # Add platform-specific settings
    if platform in config_info.platform_specific:
        content.append('')
        content.append('" Platform-specific settings for {}'.format(platform))
        for setting in config_info.platform_specific[platform]:
            content.append(setting)

    # Add mappings
    if hasattr(config_info, "mappings") and config_info.mappings:
        content.append('')
        content.append('" Key Mappings')
        for key, mapping in config_info.mappings.items():
            content.append('map {} {}'.format(key, mapping))

    # Add raw statements
    if hasattr(config_info, "raw_statements") and config_info.raw_statements:
        content.append('')
        content.append('" Custom Configurations')
        for stmt in config_info.raw_statements:
            content.append(stmt)

    # Write the file
    ctx.actions.write(
        output = output,
        content = "\n".join(content),
    )

    # Create a runfiles provider if we need to include additional files
    runfiles = ctx.runfiles(files = [output])

    return [DefaultInfo(files = depset([output]), runfiles = runfiles)]

vim_config_generator = rule(
    implementation = _vim_config_generator_impl,
    attrs = {
        "config": attr.label(
            doc = "The vim_config target to use",
            mandatory = True,
            providers = [VimConfigInfo],
        ),
        # Platform constraints
        "_windows_constraint": attr.label(
            default = "@platforms//os:windows",
        ),
        "_macos_constraint": attr.label(
            default = "@platforms//os:macos",
        ),
        "_linux_constraint": attr.label(
            default = "@platforms//os:linux",
        ),
    },
)
