"""Rules for generating fzf configuration files."""

# Define the FzfConfigInfo provider
FzfConfigInfo = provider(
    doc = "Information about fzf configuration",
    fields = {
        "settings": "Dictionary of fzf settings",
        "includes": "List of other fzf configs to include",
        "platform_specific": "Platform-specific settings",
        "variant_settings": "Variant-specific settings (work, personal, etc.)",
    },
)

def _fzf_config_impl(ctx):
    """Implementation of fzf_config rule."""

    # Process includes first to set up inheritance
    inherited_settings = {}
    inherited_platform_settings = {}
    inherited_variant_settings = {}

    # Process includes (nested configs) and inherit their values
    for include in ctx.attr.includes:
        include_info = include[FzfConfigInfo]

        # Merge settings
        for key, value in include_info.settings.items():
            inherited_settings[key] = value

        # Merge platform-specific settings
        for platform, platform_settings in include_info.platform_specific.items():
            if platform not in inherited_platform_settings:
                inherited_platform_settings[platform] = {}
            for key, value in platform_settings.items():
                inherited_platform_settings[platform][key] = value

        # Merge variant settings
        for variant, variant_settings in include_info.variant_settings.items():
            if variant not in inherited_variant_settings:
                inherited_variant_settings[variant] = {}
            for key, value in variant_settings.items():
                inherited_variant_settings[variant][key] = value

    # Create dictionaries to hold our configuration
    settings = dict(inherited_settings)
    platform_settings = dict(inherited_platform_settings)
    variant_settings = dict(inherited_variant_settings)

    # Add settings from the rule attributes
    for key, value in ctx.attr.settings.items():
        settings[key] = value

    # Parse and add platform-specific settings
    for flat_key, value in ctx.attr.platform_settings.items():
        parts = flat_key.split(".", 1)
        if len(parts) != 2:
            fail("Platform settings key must be in 'platform.key' format: {}".format(flat_key))
            
        platform, key = parts
        if platform not in platform_settings:
            platform_settings[platform] = {}
        platform_settings[platform][key] = value

    # Parse and add variant settings
    for flat_key, value in ctx.attr.variant_settings.items():
        parts = flat_key.split(".", 1)
        if len(parts) != 2:
            fail("Variant settings key must be in 'variant.key' format: {}".format(flat_key))
            
        variant, key = parts
        if variant not in variant_settings:
            variant_settings[variant] = {}
        variant_settings[variant][key] = value

    # Create the provider
    config = FzfConfigInfo(
        settings = settings,
        includes = ctx.attr.includes,
        platform_specific = platform_settings,
        variant_settings = variant_settings,
    )

    return [config]

fzf_config = rule(
    implementation = _fzf_config_impl,
    attrs = {
        "settings": attr.string_dict(
            doc = "Dictionary of fzf settings",
            default = {},
        ),
        "includes": attr.label_list(
            doc = "Other fzf_config targets to include",
            default = [],
            providers = [FzfConfigInfo],
        ),
        "platform_settings": attr.string_dict(
            doc = "Platform-specific settings (flat format: 'platform.key'='value')",
            default = {},
        ),
        "variant_settings": attr.string_dict(
            doc = "Variant-specific settings (flat format: 'variant.key'='value')",
            default = {},
        ),
    },
)

def _get_platform_string(ctx):
    """Determine the current platform."""
    if ctx.target_platform_has_constraint(ctx.attr._windows_constraint[platform_common.ConstraintValueInfo]):
        return "windows"
    elif ctx.target_platform_has_constraint(ctx.attr._macos_constraint[platform_common.ConstraintValueInfo]):
        return "macos"
    else:
        return "linux"

def _fzf_config_generator_impl(ctx):
    """Implementation for fzf_config_generator rule that generates configuration files."""

    # Get the FzfConfigInfo provider from the config target
    config_info = ctx.attr.config[FzfConfigInfo]

    # Determine the platform
    platform = _get_platform_string(ctx)

    # Determine the variant (default to "base" if not specified)
    variant = ctx.attr.variant if ctx.attr.variant else "base"

    # Prepare the output file
    output = ctx.actions.declare_file(ctx.attr.name + ".sh")
    content = []

    # Generate file header
    content.append("#!/bin/bash")
    content.append("# Generated fzf config file - DO NOT EDIT")
    content.append("# Generated by Bazel from {}".format(ctx.label))
    content.append("# Platform: {}".format(platform))
    content.append("# Variant: {}".format(variant))
    content.append("")

    # Process base settings
    content.append("# Base FZF settings")
    content.append("export FZF_DEFAULT_OPTS=\"\\")
    
    # Add all settings
    settings_list = []
    for key, value in config_info.settings.items():
        if value.lower() == "true":
            settings_list.append("--{}".format(key))
        elif value.lower() != "false":
            settings_list.append("--{}='{}'".format(key, value))
    
    # Add platform-specific settings
    if platform in config_info.platform_specific:
        platform_dict = config_info.platform_specific[platform]
        for key, value in platform_dict.items():
            if value.lower() == "true":
                settings_list.append("--{}".format(key))
            elif value.lower() != "false":
                settings_list.append("--{}='{}'".format(key, value))
    
    # Add variant-specific settings
    if variant in config_info.variant_settings:
        variant_dict = config_info.variant_settings[variant]
        for key, value in variant_dict.items():
            if value.lower() == "true":
                settings_list.append("--{}".format(key))
            elif value.lower() != "false":
                settings_list.append("--{}='{}'".format(key, value))
    
    # Join settings with line continuation
    content.append(" \\\n  ".join(settings_list))
    content.append("\"")
    
    # Add common fzf configurations for shell
    content.append("")
    content.append("# Source fzf completion and key-bindings if available")
    content.append("[ -f ~/.fzf.bash ] && source ~/.fzf.bash")
    content.append("[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh")
    content.append("")
    content.append("# Use fd if available (respects .gitignore)")
    content.append("if command -v fd &> /dev/null; then")
    content.append("  export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'")
    content.append("  export FZF_CTRL_T_COMMAND=\"$FZF_DEFAULT_COMMAND\"")
    content.append("fi")
    content.append("")

    # Write the file
    ctx.actions.write(
        output = output,
        content = "\n".join(content),
    )

    # Create a runfiles provider
    runfiles = ctx.runfiles(files = [output])

    return [DefaultInfo(files = depset([output]), runfiles = runfiles)]

fzf_config_generator = rule(
    implementation = _fzf_config_generator_impl,
    attrs = {
        "config": attr.label(
            doc = "The fzf_config target to use",
            mandatory = True,
            providers = [FzfConfigInfo],
        ),
        "variant": attr.string(
            doc = "The configuration variant to use (work, personal, etc.)",
            default = "",
        ),
        # Platform constraints
        "_windows_constraint": attr.label(
            default = "@platforms//os:windows",
        ),
        "_macos_constraint": attr.label(
            default = "@platforms//os:macos",
        ),
        "_linux_constraint": attr.label(
            default = "@platforms//os:linux",
        ),
    },
)