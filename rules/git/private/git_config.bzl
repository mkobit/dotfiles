"""
Implementation of Git configuration rules.
"""

def _git_config_impl(ctx):
    """Implementation of git_config rule."""
    output = ctx.actions.declare_file(ctx.label.name + ".gitconfig")
    
    # Build a list of input files for the action
    input_files = []
    for src in ctx.attr.srcs:
        input_files.extend(src.files.to_list())
    
    # Generate the command to combine configuration files
    cmd = ["#!/bin/bash", "set -euo pipefail", ""]
    
    # Add header
    header = ctx.attr.header
    if header:
        # Replace $(date) with actual date
        header = header.replace("$(date)", "$(date '+%Y-%m-%d %H:%M:%S')")
        cmd.append("echo '{}' > {}".format(header, output.path))
    else:
        cmd.append("echo '# Git configuration generated by Bazel' > {}".format(output.path))
        cmd.append("echo '# Generated at: '$(date '+%Y-%m-%d %H:%M:%S') >> {}".format(output.path))
    
    # Add a blank line after the header
    cmd.append("echo '' >> {}".format(output.path))
    
    # Include each source file with a section comment
    for i, src_file in enumerate(input_files):
        section_name = src_file.basename.replace(".gitconfig", "")
        cmd.append("echo '# {}' >> {}".format(section_name, output.path))
        cmd.append("cat {} >> {}".format(src_file.path, output.path))
        cmd.append("echo '' >> {}".format(output.path))
    
    # Add footer if specified
    if ctx.attr.footer:
        cmd.append("echo '{}' >> {}".format(ctx.attr.footer, output.path))
    else:
        cmd.append("echo '# End of generated Git configuration' >> {}".format(output.path))
    
    # Join commands into a shell script
    cmd_str = "\n".join(cmd)
    
    # Execute the command to create the output file
    ctx.actions.run_shell(
        outputs = [output],
        inputs = input_files,
        command = cmd_str,
        mnemonic = "GitConfig",
        progress_message = "Generating Git configuration %s" % output.path,
    )
    
    return [DefaultInfo(
        files = depset([output]),
        runfiles = ctx.runfiles(files = [output]),
    )]

git_config = rule(
    implementation = _git_config_impl,
    attrs = {
        "srcs": attr.label_list(
            doc = "Input Git configuration files to be combined",
            allow_files = [".gitconfig"],
            mandatory = True,
        ),
        "header": attr.string(
            doc = "Optional header to include at the top of the generated config",
            default = "",
        ),
        "footer": attr.string(
            doc = "Optional footer to include at the end of the generated config",
            default = "",
        ),
    },
)

def _git_test_impl(ctx):
    """Implementation of git_test rule."""
    # Get the Git configuration file to test
    config = ctx.file.config
    
    # Create a test script
    test_script = ctx.actions.declare_file(ctx.label.name + ".sh")
    
    ctx.actions.write(
        output = test_script,
        content = """#!/bin/bash
set -euo pipefail

# Try to find git in the system
if command -v git > /dev/null 2>&1; then
    GIT="git"
else
    echo "WARNING: No git executable found - test will be skipped"
    echo "PASS: Skipping test due to missing git"
    exit 0
fi

CONFIG="{config}"
echo "Testing Git configuration: $CONFIG with git executable: $GIT"

# Validate syntax by parsing the config
$GIT config --file "$CONFIG" --list || {{
    echo "Git configuration has syntax errors"
    exit 1
}}

echo "Git configuration syntax is valid!"
exit 0
""".format(
            config = config.short_path,
        ),
        is_executable = True,
    )
    
    # Create runfiles for testing
    runfiles = ctx.runfiles(files = [config])
    
    return [DefaultInfo(
        executable = test_script,
        runfiles = runfiles,
    )]

git_test = rule(
    implementation = _git_test_impl,
    attrs = {
        "config": attr.label(
            doc = "The Git configuration file to test",
            allow_single_file = [".gitconfig"],
            mandatory = True,
        ),
    },
    test = True,
)