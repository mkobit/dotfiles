"""
Implementation of ZSH configuration rules.
"""

def _zsh_config_impl(ctx):
    """Implementation of zsh_config rule."""
    output = ctx.actions.declare_file(ctx.label.name + ".zsh")
    
    # Build a list of input files for the action
    input_files = []
    for src in ctx.attr.srcs:
        input_files.extend(src.files.to_list())
    
    # Generate the command to combine configuration files
    cmd = ["#!/bin/bash", "set -euo pipefail", ""]
    
    # Add header
    header = ctx.attr.header
    if header:
        # Replace $(date) with actual date
        header = header.replace("$(date)", "$(date '+%Y-%m-%d %H:%M:%S')")
        cmd.append("echo '{}' > {}".format(header, output.path))
    else:
        cmd.append("echo '# ZSH configuration generated by Bazel' > {}".format(output.path))
        cmd.append("echo '# Generated at: '$(date '+%Y-%m-%d %H:%M:%S') >> {}".format(output.path))
    
    # Add a blank line after the header
    cmd.append("echo '' >> {}".format(output.path))
    
    # Include each source file with a section comment
    for i, src_file in enumerate(input_files):
        section_name = src_file.basename
        cmd.append("echo '# {}' >> {}".format(section_name, output.path))
        cmd.append("cat {} >> {}".format(src_file.path, output.path))
        cmd.append("echo '' >> {}".format(output.path))
    
    # Add footer if specified
    if ctx.attr.footer:
        cmd.append("echo '{}' >> {}".format(ctx.attr.footer, output.path))
    else:
        cmd.append("echo '# End of generated ZSH configuration' >> {}".format(output.path))
    
    # Join commands into a shell script
    cmd_str = "\n".join(cmd)
    
    # Execute the command to create the output file
    ctx.actions.run_shell(
        outputs = [output],
        inputs = input_files,
        command = cmd_str,
        mnemonic = "ZshConfig",
        progress_message = "Generating ZSH configuration %s" % output.path,
    )
    
    return [DefaultInfo(
        files = depset([output]),
        runfiles = ctx.runfiles(files = [output]),
    )]

zsh_config = rule(
    implementation = _zsh_config_impl,
    attrs = {
        "srcs": attr.label_list(
            doc = "Input ZSH configuration files to be combined",
            allow_files = True,
            mandatory = True,
        ),
        "header": attr.string(
            doc = "Optional header to include at the top of the generated config",
            default = "",
        ),
        "footer": attr.string(
            doc = "Optional footer to include at the end of the generated config",
            default = "",
        ),
    },
)

def _zsh_test_impl(ctx):
    """Implementation of zsh_test rule."""
    # Get the ZSH configuration file to test
    config = ctx.file.config
    
    # Create a test script
    test_script = ctx.actions.declare_file(ctx.label.name + ".sh")
    
    ctx.actions.write(
        output = test_script,
        content = """#!/bin/bash
set -euo pipefail

# Use the system zsh or the one defined in PATH
ZSH="${{ZSH_BIN:-zsh}}"

CONFIG="{config}"
echo "Testing ZSH configuration: $CONFIG with ZSH executable: $ZSH"

# Validate syntax by running zsh -n (no execution, just syntax check)
$ZSH -n "$CONFIG" || {{
    echo "ZSH configuration has syntax errors"
    exit 1
}}

echo "ZSH configuration syntax is valid!"
exit 0
""".format(
            config = config.short_path,
        ),
        is_executable = True,
    )
    
    # Create runfiles for testing
    runfiles = ctx.runfiles(files = [config])
    
    return [DefaultInfo(
        executable = test_script,
        runfiles = runfiles,
    )]

zsh_test = rule(
    implementation = _zsh_test_impl,
    attrs = {
        "config": attr.label(
            doc = "The ZSH configuration file to test",
            allow_single_file = True,
            mandatory = True,
        ),
    },
    test = True,
)