load("//modules/rules:dotfile.bzl", "dotfile", "dotfile_group")
load("//modules/toolchains:jq_toolchain.bzl", "jq_test", "jq_toolchain")
load("//modules/jq:jq_rules.bzl", "jq_library", "jq_module")

package(default_visibility = ["//visibility:public"])

# Create the jq toolchain instance
jq_toolchain(
    name = "jq_toolchain_target",
    tags = ["jq"],
)

# Simple system integration test for jq using the jq_test rule
jq_test(
    name = "system_integration_test",
    tags = ["manual"],  # Don't run automatically in CI
)

# Directory structure setup for jq modules
filegroup(
    name = "jq_module_dirs",
    srcs = glob(["modules/**"]),
)

# Include the local filesystem modules
jq_module(
    name = "utils",
    src = "modules/utils.jq",
)

jq_module(
    name = "advanced",
    src = "modules/advanced.jq",
    imports = [":utils"],
    search_paths = ["$(pwd)/tools/jq/modules"],
)

# Base jq module with utility functions
jq_module(
    name = "base",
    content = """
# Base utility functions for jq
# Generated by Bazel

def is_string: type == "string";
def is_number: type == "number";
def is_object: type == "object";
def is_array: type == "array";
def is_null: type == "null";
def is_boolean: type == "boolean";

# Object utilities
def keys_sorted: keys | sort;
def has_key(k): k as $k | has($k);
def merge_objects(o): reduce o as $item ({}; . + $item);

# Array utilities
def unique_sorted: unique | sort;
def concat_arrays: reduce .[] as $item ([]; . + $item);
def avg: add / length;
def sum_by(f): map(f) | add;
def group_by_to_map(f): group_by(f) | map({(.[0] | f): .}) | add;
""",
    search_paths = ["~/.jq", "$(pwd)/tools/jq/modules"],
)

# JSON formatting module
jq_module(
    name = "formatting",
    content = """
# JSON formatting utilities
# Generated by Bazel

import "base" as base;

# Pretty printing with customizable indentation
def pretty_print(indent): 
    . as $root | 
    [paths(scalars) as $path | {
        path: $path | join("."),
        value: getpath($path)
    }] |
    if indent == null then . else .[] | "\\(" + indent * (.path | length) + .path + ": " + .value) end;

# Format dates to ISO 8601
def format_date: strftime("%Y-%m-%dT%H:%M:%SZ");

# Convert objects to CSV format
def to_csv:
    if base::is_array and (.[0] | base::is_object) then
        # Get all possible keys across all objects
        (map(keys) | add | unique) as $cols |
        # Output the header row
        [$cols] +
        # Output data rows
        map(. as $row | $cols | map($row[.])) |
        map(map(tostring) | join(",")) |
        join("\\n")
    else "Error: Input must be an array of objects" end;
""",
    imports = [":base"],
)

# Create a library of jq modules
jq_library(
    name = "jq_modules",
    modules = [
        ":base",
        ":formatting",
        ":utils",
        ":advanced",
    ],
    search_paths = [
        "~/.jq",
        "$(pwd)/tools/jq/modules",
    ],
)

# Test for the base module
jq_test(
    name = "base_test",
    module = ":base",
    input_data = '{"foo": 42, "bar": "hello"}',
    expected_output = '["bar", "foo"]',
)

# Test for the formatting module
jq_test(
    name = "formatting_test",
    module = ":formatting",
    input_data = '[{"name": "Alice", "age": 30}, {"name": "Bob", "age": 40}]',
    expected_output = '"name,age\\nAlice,30\\nBob,40"',
)

# Test for the utils module
jq_test(
    name = "utils_test",
    module = ":utils",
    input_data = '"  hello world  "',
    expected_output = '"hello world"',
)

# Test for the advanced module
jq_test(
    name = "advanced_test",
    module = ":advanced",
    input_data = '[1, 2, 3, 4, 5]',
    expected_output = '{"sum":15,"mean":3,"median":3,"count":5,"min":1,"max":5}',
)

# Generate installation script for jq modules
genrule(
    name = "print_modules_path",
    srcs = [":jq_modules"],
    outs = ["jq_modules_path.txt"],
    cmd = "echo 'To use these jq modules, add the following paths to your jq search path:' > $@ && " +
          "echo '' >> $@ && " +
          "echo '  -L $(pwd)/tools/jq/modules' >> $@ && " +
          "echo '' >> $@ && " +
          "echo 'For example, to use the base module:' >> $@ && " +
          "echo 'jq -L $(pwd)/tools/jq/modules -n \"import \\\"base\\\" as b; [1,2,3] | b::avg\"' >> $@ && " +
          "echo '' >> $@",
)

# Rule to create jq module directories
genrule(
    name = "create_module_dirs",
    srcs = [],
    outs = ["_create_module_dirs.sh"],
    cmd = "echo '#!/bin/bash' > $@ && " +
          "echo 'mkdir -p ~/.jq' >> $@ && " +
          "echo 'mkdir -p $(GENDIR)/tools/jq/modules' >> $@ && " +
          "echo 'echo \"Created jq module directories\"' >> $@ && " +
          "chmod +x $@",
    executable = True,
)

# Install the modules to the user's ~/.jq directory
genrule(
    name = "install_modules",
    srcs = [
        ":base",
        ":formatting",
        ":utils",
        ":advanced",
    ],
    outs = ["_install_modules.sh"],
    cmd = "echo '#!/bin/bash' > $@ && " +
          "echo 'mkdir -p ~/.jq' >> $@ && " +
          "echo 'cp -v $(GENDIR)/tools/jq/base.jq ~/.jq/' >> $@ && " +
          "echo 'cp -v $(GENDIR)/tools/jq/formatting.jq ~/.jq/' >> $@ && " +
          "echo 'cp -v $(GENDIR)/tools/jq/utils.jq ~/.jq/' >> $@ && " +
          "echo 'cp -v $(GENDIR)/tools/jq/advanced.jq ~/.jq/' >> $@ && " +
          "echo \"Installed jq modules to ~/.jq/\"' >> $@ && " +
          "chmod +x $@",
    executable = True,
)