"""
Common utilities for rule implementations.

This module provides reusable functions and patterns for creating
configuration management rules.
"""

def create_config_rule(
        rule_name,
        file_extension,
        mnemonic,
        allowed_extensions = None,
        header_template = None,
        footer_template = None):
    """Creates a configuration rule that combines multiple source files.

    Args:
        rule_name: Name of the rule
        file_extension: Extension for output file (e.g., ".zsh", ".gitconfig")
        mnemonic: Mnemonic for the action
        allowed_extensions: List of allowed file extensions for sources
        header_template: Template for header comment
        footer_template: Template for footer comment

    Returns:
        A rule implementation function
    """

    def _impl(ctx):
        output = ctx.actions.declare_file(ctx.label.name + file_extension)

        # Build list of input files
        input_files = []
        for src in ctx.attr.srcs:
            input_files.extend(src.files.to_list())

        # Generate shell commands to combine files
        cmd = ["#!/bin/bash", "set -euo pipefail", ""]

        # Add header
        header = ctx.attr.header
        if header:
            # Use heredoc to safely handle headers with special characters
            header_content = header.replace("$(date)", "$(date '+%Y-%m-%d %H:%M:%S')")
            cmd.append("cat > {} << 'HEADER_EOF'".format(output.path))
            cmd.append(header_content)
            cmd.append("HEADER_EOF")
        else:
            # Default header
            default_header = header_template or "# {} configuration generated by Bazel".format(rule_name.title())
            cmd.append("echo '{}' > {}".format(default_header, output.path))
            cmd.append('echo "# Generated at: $(date \'+%Y-%m-%d %H:%M:%S\')" >> {}'.format(output.path))

        # Add blank line after header
        cmd.append("echo '' >> {}".format(output.path))

        # Include each source file with section comment
        for src_file in input_files:
            section_name = src_file.basename
            if file_extension in section_name:
                section_name = section_name.replace(file_extension, "")
            cmd.append("echo '# {}' >> {}".format(section_name, output.path))
            cmd.append("cat {} >> {}".format(src_file.path, output.path))
            cmd.append("echo '' >> {}".format(output.path))

        # Add footer
        if ctx.attr.footer:
            cmd.append("echo '{}' >> {}".format(ctx.attr.footer, output.path))
        else:
            default_footer = footer_template or "# End of generated {} configuration".format(rule_name)
            cmd.append("echo '{}' >> {}".format(default_footer, output.path))

        # Execute the command
        cmd_str = "\n".join(cmd)
        ctx.actions.run_shell(
            outputs = [output],
            inputs = input_files,
            command = cmd_str,
            mnemonic = mnemonic,
            progress_message = "Generating {} configuration %s".format(rule_name) % output.path,
        )

        return [DefaultInfo(
            files = depset([output]),
            runfiles = ctx.runfiles(files = [output]),
        )]

    # Define standard attributes
    attrs = {
        "srcs": attr.label_list(
            doc = "Input {} configuration files to be combined".format(rule_name),
            allow_files = allowed_extensions or True,
            mandatory = True,
        ),
        "header": attr.string(
            doc = "Optional header to include at the top of the generated config",
            default = "",
        ),
        "footer": attr.string(
            doc = "Optional footer to include at the end of the generated config",
            default = "",
        ),
    }

    return rule(
        implementation = _impl,
        attrs = attrs,
    )

def create_config_test_rule(
        rule_name,
        toolchain_type,
        validation_commands,
        file_extensions = None):
    """Creates a test rule for configuration files.

    Args:
        rule_name: Name of the rule
        toolchain_type: Toolchain type label
        validation_commands: List of validation command templates
        file_extensions: List of allowed file extensions

    Returns:
        A test rule implementation function
    """

    def _impl(ctx):
        # Access the toolchain
        toolchain = ctx.toolchains[toolchain_type]
        tool_info = getattr(toolchain, rule_name + "info")

        # Get the configuration file to test
        config = ctx.file.config

        # Copy the config file to a predictable location
        # Extract extension from original file or use a default
        if "." in config.basename:
            config_extension = "." + config.basename.split(".")[-1]
        else:
            config_extension = ".config"
        copied_config = ctx.actions.declare_file(ctx.label.name + "_test" + config_extension)
        ctx.actions.run_shell(
            outputs = [copied_config],
            inputs = [config],
            command = "cp '{}' '{}'".format(config.path, copied_config.path),
        )

        # Create test script
        test_script = ctx.actions.declare_file(ctx.label.name + ".sh")

        # Build test script content
        tool_path_attr = "{}_path".format(rule_name)
        version_attr = "{}_version".format(rule_name)

        tool_path = getattr(tool_info, tool_path_attr)
        tool_version = getattr(tool_info, version_attr)

        script_content = '''#!/bin/bash
set -euo pipefail

TOOL="{tool_path}"
VERSION="{tool_version}"
CONFIG="{config_path}"

echo "Testing {rule_name} configuration using $TOOL ($VERSION)"
echo "Configuration file: $CONFIG"

# Ensure we're working with the correct path (make it absolute if needed)
if [[ "$CONFIG" != /* ]]; then
    CONFIG="$PWD/$CONFIG"
fi

echo "Using absolute config path: $CONFIG"

'''.format(
            tool_path = tool_path,
            tool_version = tool_version,
            config_path = copied_config.short_path,
            rule_name = rule_name,
        )

        # Add validation commands
        for cmd_template in validation_commands:
            script_content += cmd_template.format(
                tool_path = tool_path,
                config_path = "$CONFIG",
            ) + "\n"

        script_content += '''
echo "{} configuration validation passed!"
exit 0
'''.format(rule_name.title())

        ctx.actions.write(
            output = test_script,
            content = script_content,
            is_executable = True,
        )

        return [DefaultInfo(
            executable = test_script,
            runfiles = ctx.runfiles(files = [copied_config]),
        )]

    return rule(
        implementation = _impl,
        attrs = {
            "config": attr.label(
                doc = "The {} configuration file to test".format(rule_name),
                allow_single_file = file_extensions,
                mandatory = True,
            ),
        },
        test = True,
        toolchains = [toolchain_type],
    )
